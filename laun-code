interface AppFlows {
  [key: string]: any; // Replace `any` with the actual type if known
}

import { Injectable } from '@angular/core';

/**
 * Service to determine the application flow based on the product ID.
 */
@Injectable({
  providedIn: 'root'
})
export class FlowDeterminationService {
  
  /**
   * Mapping of product IDs to application flows.
   */
  private appFlows = {
    'CheckingAccount': 'EDB',
    'CreditCard': 'CC',
    // Add more product and flow mappings as needed
  };

  /**
   * Determines the flow based on the productId.
   * @param productId The product ID provided to determine the application flow.
   * @returns The corresponding flow for the given product ID, or 'default' if not found.
   */
  determineFlow(productId: string): string {
    return this.appFlows[productId] || 'default';
  }
}

-----------
import { FlowDeterminationService } from './flow-determination.service';

describe('FlowDeterminationService', () => {
  let service: FlowDeterminationService;

  beforeEach(() => {
    service = new FlowDeterminationService();
  });

  it('should return EDB for CheckingAccount', () => {
    expect(service.determineFlow('CheckingAccount')).toBe('EDB');
  });

  it('should return CC for CreditCard', () => {
    expect(service.determineFlow('CreditCard')).toBe('CC');
  });

  it('should return default for unknown productId', () => {
    expect(service.determineFlow('UnknownProduct')).toBe('default');
  });
});



------------

import { Injectable } from '@angular/core';
import { FlowDeterminationService } from './flow-determination.service';

/**
 * Service to get the list of navigation routes based on the application flow.
 */
@Injectable({
  providedIn: 'root'
})
export class FlowBasedNavigationService {

  /**
   * Mapping of flows to route arrays.
   */
  private flowRoutes = {
    'EDB': [
      'lets-get-started',
      'personal-info',
      'contact-info',
      'send-otp',
      'validate-otp',
      'address-info',
      'personal-info-review'
    ],
    'CC': [
      'lets-get-started',
      'personal-info',
      'contact-info',
      'validate-otp',
      'address-info'
    ]
  };

  constructor(private flowDeterminationService: FlowDeterminationService) {}

  /**
   * Returns the list of navigation routes based on the flow derived from productId.
   * @param productId The product ID used to determine the flow.
   * @returns An array of route paths.
   */
  getNavigationList(productId: string): string[] {
    const appFlow = this.flowDeterminationService.determineFlow(productId);
    return this.flowRoutes[appFlow] || [];
  }
}
------------------
import { FlowBasedNavigationService } from './flow-based-navigation.service';
import { FlowDeterminationService } from './flow-determination.service';

describe('FlowBasedNavigationService', () => {
  let service: FlowBasedNavigationService;
  let flowDeterminationService: FlowDeterminationService;

  beforeEach(() => {
    flowDeterminationService = new FlowDeterminationService();
    service = new FlowBasedNavigationService(flowDeterminationService);
  });

  it('should return EDB flow routes for CheckingAccount', () => {
    const result = service.getNavigationList('CheckingAccount');
    expect(result).toEqual([
      'lets-get-started',
      'personal-info',
      'contact-info',
      'send-otp',
      'validate-otp',
      'address-info',
      'personal-info-review'
    ]);
  });

  it('should return CC flow routes for CreditCard', () => {
    const result = service.getNavigationList('CreditCard');
    expect(result).toEqual([
      'lets-get-started',
      'personal-info',
      'contact-info',
      'validate-otp',
      'address-info'
    ]);
  });

  it('should return an empty array for unknown flow', () => {
    const result = service.getNavigationList('UnknownProduct');
    expect(result).toEqual([]);
  });
});
--------------------
import { Injectable } from '@angular/core';
import { Router } from '@angular/router';
import { Location } from '@angular/common';
import { FlowBasedNavigationService } from './flow-based-navigation.service';

/**
 * Service to manage the navigation between pages, including forward and backward navigation.
 */
@Injectable({
  providedIn: 'root'
})
export class NavigationService {
  
  /**
   * The current navigation stack, containing the routes for the current flow.
   */
  private currentStack: string[] = [];

  /**
   * The current index of the route in the navigation stack.
   */
  private currentIndex: number = 0;

  constructor(
    private router: Router, 
    private location: Location, 
    private flowBasedNavigationService: FlowBasedNavigationService
  ) {}

  /**
   * Initializes the navigation stack based on the provided productId.
   * @param productId The product ID used to determine the navigation flow.
   */
  init(productId: string) {
    this.currentStack = this.flowBasedNavigationService.getNavigationList(productId);
    this.currentIndex = 0;
  }

  /**
   * Navigates to the next route in the stack, if available.
   */
  navigateNext() {
    if (this.currentIndex < this.currentStack.length - 1) {
      this.currentIndex++;
      this.navigateTo(this.currentStack[this.currentIndex]);
    }
  }

  /**
   * Navigates to the previous route in the stack, if available.
   */
  navigateBack() {
    if (this.currentIndex > 0) {
      this.currentIndex--;
      this.navigateTo(this.currentStack[this.currentIndex]);
    }
  }

  /**
   * Navigates directly to a specific route.
   * @param path The path to navigate to.
   * @param queryParams (optional) Any query parameters to include in the navigation.
   */
  navigateTo(path: string, queryParams?: any) {
    this.router.navigate([path], { queryParams });
  }

  /**
   * Returns the current route in the stack.
   * @returns The current route string.
   */
  getCurrentRoute(): string {
    return this.currentStack[this.currentIndex];
  }

  /**
   * Returns the next route in the stack, or null if none is available.
   * @returns The next route string, or null.
   */
  getNextRoute(): string | null {
    if (this.currentIndex < this.currentStack.length - 1) {
      return this.currentStack[this.currentIndex + 1];
    }
    return null;
  }

  /**
   * Returns the previous route in the stack, or null if none is available.
   * @returns The previous route string, or null.
   */
  getPreviousRoute(): string | null {
    if (this.currentIndex > 0) {
      return this.currentStack[this.currentIndex - 1];
    }
    return null;
  }
}
--------------------
import { TestBed } from '@angular/core/testing';
import { Router } from '@angular/router';
import { Location } from '@angular/common';
import { FlowBasedNavigationService } from './flow-based-navigation.service';
import { NavigationService } from './navigation.service';

describe('NavigationService', () => {
  let service: NavigationService;
  let mockRouter: jest.Mocked<Router>;
  let mockLocation: jest.Mocked<Location>;
  let mockFlowBasedNavigationService: jest.Mocked<FlowBasedNavigationService>;

  beforeEach(() => {
    mockRouter = {
      navigate: jest.fn(),
    } as any;

    mockLocation = {
      back: jest.fn(),
    } as any;

    mockFlowBasedNavigationService = {
      getNavigationList: jest.fn(),
    } as any;

    TestBed.configureTestingModule({
      providers: [
        NavigationService,
        { provide: Router, useValue: mockRouter },
        { provide: Location, useValue: mockLocation },
        { provide: FlowBasedNavigationService, useValue: mockFlowBasedNavigationService },
      ],
    });

    service = TestBed.inject(NavigationService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });

  describe('init', () => {
    it('should initialize the navigation stack and index', () => {
      const productId = 'CheckingAccount';
      const navigationList = ['route1', 'route2'];
      mockFlowBasedNavigationService.getNavigationList.mockReturnValue(navigationList);

      service.init(productId);

      expect(mockFlowBasedNavigationService.getNavigationList).toHaveBeenCalledWith(productId);
      expect(service['currentStack']).toEqual(navigationList);
      expect(service['currentIndex']).toBe(0);
    });
  });

  describe('navigateNext', () => {
    it('should navigate to the next route if available', () => {
      service['currentStack'] = ['route1', 'route2'];
      service['currentIndex'] = 0;

      service.navigateNext();

      expect(service['currentIndex']).toBe(1);
      expect(mockRouter.navigate).toHaveBeenCalledWith(['route2']);
    });

    it('should not navigate if there is no next route', () => {
      service['currentStack'] = ['route1'];
      service['currentIndex'] = 0;

      service.navigateNext();

      expect(service['currentIndex']).toBe(0);
      expect(mockRouter.navigate).not.toHaveBeenCalled();
    });
  });

  describe('navigateBack', () => {
    it('should navigate to the previous route if available', () => {
      service['currentStack'] = ['route1', 'route2'];
      service['currentIndex'] = 1;

      service.navigateBack();

      expect(service['currentIndex']).toBe(0);
      expect(mockRouter.navigate).toHaveBeenCalledWith(['route1']);
    });

    it('should not navigate if there is no previous route', () => {
      service['currentStack'] = ['route1'];
      service['currentIndex'] = 0;

      service.navigateBack();

      expect(service['currentIndex']).toBe(0);
      expect(mockRouter.navigate).not.toHaveBeenCalled();
    });
  });

  describe('navigateTo', () => {
    it('should navigate to the specified path with optional query parameters', () => {
      const path = 'some/path';
      const queryParams = { key: 'value' };

      service.navigateTo(path, queryParams);

      expect(mockRouter.navigate).toHaveBeenCalledWith([path], { queryParams });
    });
  });

  describe('getCurrentRoute', () => {
    it('should return the current route in the stack', () => {
      service['currentStack'] = ['route1', 'route2'];
      service['currentIndex'] = 1;

      expect(service.getCurrentRoute()).toBe('route2');
    });
  });

  describe('getNextRoute', () => {
    it('should return the next route if available', () => {
      service['currentStack'] = ['route1', 'route2'];
      service['currentIndex'] = 0;

      expect(service.getNextRoute()).toBe('route2');
    });

    it('should return null if there is no next route', () => {
      service['currentStack'] = ['route1'];
      service['currentIndex'] = 0;

      expect(service.getNextRoute()).toBeNull();
    });
  });

  describe('getPreviousRoute', () => {
    it('should return the previous route if available', () => {
      service['currentStack'] = ['route1', 'route2'];
      service['currentIndex'] = 1;

      expect(service.getPreviousRoute()).toBe('route1');
    });

    it('should return null if there is no previous route', () => {
      service['currentStack'] = ['route1'];
      service['currentIndex'] = 0;

      expect(service.getPreviousRoute()).toBeNull();
    });
  });
});

